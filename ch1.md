## 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

### 신뢰성이란

* 하드웨어 결함, 소프트웨어 결함, 인적 결함에 직면하더라도 지속적으로 올바르게 동작하는가?
* 결함*fault*?
    * 예상한 사양에서 벗어난 시스템 구성으로 장애*failure*와는 다름. 장애는 원하는 수준에서 정확한 기능을 제공하지 못하는 것. 결함으로 인해 장애가 발생하지 않도록 해야 
* 보안 문제 등 일부 결함은 해결보다 예방이 더 필요한 경우가 있으니 주의
* Netflix 의 [Chaos Monkey](https://netflix.github.io/chaosmonkey/ "Home - Chaos Monkey") 등을 이용한 [카오스 엔지니어링](https://en.wikipedia.org/wiki/Chaos_engineering) 도 한 방법. 무작위로 프로세스를 끄는 등 장애를 일으켜서 취약점을 찾고 보완
* 하드웨어 결함
    * 일반적으로 하드웨어 구성 요소에 중복을 추가. 예를 들어 RAID 구성 디스크, 핫 스왑 가능한 CPU 등
    * 클라우드 플랫폼은 단일 장비 신뢰성보다 유연성과 탄력성을 중시. 가상 인스턴스를 사용할 수 없게 되는 경우가 빈번
    * 전체 장비의 결함에 대비하려면 하드웨어를 통째로 중복을 추가하거나 소프트웨어 내결함성 기술을 사용
* 소프트웨어 결함
    * 한 결함이 연쇄적으로 다른 결함을 일으킴
    * 잘못된 입력, 자원의 과도한 사용 등 가정하지 않은 환경에 대비
    * 열심히 테스트, 프로세스 격리, 재시작, 모니터링 등 많은 준비가 필요
* 인적 결함
    * 추상화된 인터페이스, 테스트용 샌드박스 마련, 모니터링, 조직 교육과 실습 등 준비 필요
    
### 확장성이란

* 부하가 증가할 때 추가 자원을 투입하여 성능을 잘 유지하는가?
* 부하 기술하기
    * Twitter 의 경우 내가 글을 쓰면 내 팔로워 모두의 피드에도 write 가 필요. 바로 피드에 넣어 줄 것인가, 아니면 피드 주인이 읽기를 기다릴 것인가?
    * 팔로워 숫자에 따라 write 동작의 횟수가 크게 다를 것이고 그게 부하를 기술하는 핵심 변수가 될 수 있음
* 성능 기술하기
    * Hadoop 등에서는 throughput, 서버라면 response time 등
    * 평균보다는 백분위를 추천. p999(99.9%) 가 < 0.01 초 이런 식으로
    * Service Level Agreement, Service Level Objective 도 백분위를 자주 씀
    
### 유지보수성이란

* 유지보수 하기에 얼마나 편리한가?
* 운용성
    * 동작에 대한 가시성 제공, 자동화와 통합, 좋은 문서, 개별 장비 의존성 회피, 자기 회복 가능, 관리자가 제어 가능 등
* 단순성
    * 우발적 복잡도?
        * 문제가 아니라 구현에서 발생하는 복잡도. 즉 문제를 풀기 위해 큐부터 만들어야 한다면 거기서 생기는 복잡도
        * 적절한 추상화로 줄일 수 있음
* 발전성
    * 새로운 요구를 쉽게 추가할 수 있는가?